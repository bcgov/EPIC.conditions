"""add_management_plan_table

Revision ID: c7cbe44e54fc
Revises: f62a0f136cad
Create Date: 2025-06-19 16:05:18.488843

"""
from alembic import op
from datetime import datetime
from io import StringIO
import sqlalchemy as sa
from sqlalchemy.sql import text
import csv
import re


# revision identifiers, used by Alembic.
revision = 'c7cbe44e54fc'
down_revision = 'f62a0f136cad'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('management_plans',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('condition_id', sa.Integer(), nullable=False),
        sa.Column('name', sa.Text(), nullable=True),
        sa.Column('is_approved', sa.Boolean(), nullable=True, server_default=sa.text('false')),
        sa.Column('created_date', sa.DateTime(), nullable=False),
        sa.Column('updated_date', sa.DateTime(), nullable=True),
        sa.Column('created_by', sa.String(length=50), nullable=True),
        sa.Column('updated_by', sa.String(length=50), nullable=True),
        sa.ForeignKeyConstraint(['condition_id'], ['condition.conditions.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        schema='condition'
    )

    with op.batch_alter_table('condition_attributes', schema='condition') as batch_op:
        batch_op.add_column(sa.Column('management_plan_id', sa.Integer(), nullable=True))
        batch_op.create_foreign_key(None, 'management_plans', ['management_plan_id'], ['id'], referent_schema='condition', ondelete='CASCADE')

    with op.batch_alter_table('conditions', schema='condition') as batch_op:
        batch_op.add_column(sa.Column('requires_management_plan', sa.Boolean(), nullable=True))

    # Fetch conditions where "Requires management plan(s)" is "true"
    # Attribute key ID 1 is "Requires management plan(s)"
    conn = op.get_bind()
    requires_plan_sql = conn.execute(text("""
        SELECT DISTINCT condition_id
        FROM condition.condition_attributes
        WHERE attribute_key_id = 1
          AND LOWER(attribute_value) = 'true'
    """))

    condition_ids_with_plans = [row[0] for row in requires_plan_sql]

    if not condition_ids_with_plans:
        return  # Nothing to do

    # Fetch all plan names for conditions that require plans
    plan_names_sql = text("""
        SELECT condition_id, attribute_value
        FROM condition.condition_attributes
        WHERE attribute_key_id = 3
        AND condition_id = ANY(:condition_ids)
        AND attribute_value IS NOT NULL
    """)
    rows = conn.execute(plan_names_sql, {"condition_ids": condition_ids_with_plans}).fetchall()

    normalized_plan_entries = []  # list of (condition_id, plan_name)
    for condition_id, value in rows:
        # Detect if it’s a list-style string like "{abc, def}"
        if value.strip().startswith('{') and value.strip().endswith('}'):
            inner = value.strip()[1:-1]
            reader = csv.reader(StringIO(inner), skipinitialspace=True, escapechar='\\')
            for name in next(reader):
                name = name.strip()
                if name:
                    normalized_plan_entries.append((condition_id, name))
        else:
            normalized_plan_entries.append((condition_id, value.strip()))

    # Fetch original attribute values for all relevant conditions (attribute_key_id 2–10)
    original_attrs_by_condition = {}
    attribute_rows = conn.execute(text("""
        SELECT condition_id, attribute_key_id, attribute_value
        FROM condition.condition_attributes
        WHERE attribute_key_id IN (2,3,4,5,6,7,8,9,10)
          AND condition_id = ANY(:condition_ids)
    """), {"condition_ids": condition_ids_with_plans}).fetchall()

    for condition_id, attribute_key_id, attribute_value in attribute_rows:
        original_attrs_by_condition.setdefault(condition_id, []).append((attribute_key_id,
                                                                         attribute_value))

    # Insert into management_plans
    inserted_plan_map = {}
    first_plan_done = set()

    for condition_id, plan_name in normalized_plan_entries:
        # Fetch is_condition_attributes_approved for the condition
        approved_result = conn.execute(text("""
            SELECT is_condition_attributes_approved
            FROM condition.conditions
            WHERE id = :condition_id
        """), {"condition_id": condition_id})

        is_approved = approved_result.scalar()  # returns None or boolean

        insert_sql = text("""
            INSERT INTO condition.management_plans (condition_id, name, is_approved, created_date)
            VALUES (:condition_id, :name, :is_approved, :created_date)
            RETURNING id
        """)
        result = conn.execute(insert_sql, {
            "condition_id": condition_id,
            "name": plan_name,
            "is_approved": is_approved,
            "created_date": datetime.utcnow(),
        })
        inserted_id = result.fetchone()[0]
        inserted_plan_map[(condition_id, plan_name)] = inserted_id

        # Attach attributes to plan
        attrs = original_attrs_by_condition.get(condition_id, [])
        # Update condition_attributes with management_plan_id
        if condition_id not in first_plan_done:
            # Update existing attributes
            for attr_key_id, _ in attrs:
                conn.execute(text("""
                    UPDATE condition.condition_attributes
                    SET management_plan_id = :plan_id
                    WHERE condition_id = :condition_id
                      AND attribute_key_id = :attribute_key_id
                      AND management_plan_id IS NULL
                """), {
                    "plan_id": inserted_id,
                    "condition_id": condition_id,
                    "attribute_key_id": attr_key_id
                })
            first_plan_done.add(condition_id)
        else:
            # Insert duplicates for other plans
            for attr_key_id, attr_value in attrs:
                conn.execute(text("""
                    INSERT INTO condition.condition_attributes (
                        condition_id, attribute_key_id, attribute_value, management_plan_id, created_date
                    )
                    VALUES (:condition_id, :attribute_key_id, :attribute_value, :plan_id, :created_date)
                """), {
                    "condition_id": condition_id,
                    "attribute_key_id": attr_key_id,
                    "attribute_value": attr_value,
                    "plan_id": inserted_id,
                    "created_date": datetime.utcnow()
                })

    conn.execute(sa.text("""
        UPDATE condition.conditions
        SET requires_management_plan = TRUE
        WHERE id IN (
            SELECT DISTINCT condition_id
            FROM condition.condition_attributes
            WHERE attribute_key_id = 1
            AND LOWER(attribute_value) = 'true'
        )
    """))
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('conditions', schema='condition') as batch_op:
        batch_op.drop_column('requires_management_plan')

    with op.batch_alter_table('condition_attributes', schema='condition') as batch_op:
        batch_op.drop_column('management_plan_id')

    op.drop_table('management_plans', schema='condition')
    # ### end Alembic commands ###
